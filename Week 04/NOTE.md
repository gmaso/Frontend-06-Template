# 第四周学习笔记

## 20201116 字符串分析算法

从简单到难：
- 字典树
  
  精确匹配字符串，适合大量高重复字符串的存储与分析。比如一亿个字符串里出现数量前 50 的字符串，比如搜索关键词分析。

- KMP

  在长字符串里找短字符串（模式）。直接暴力匹配，最差是 O(MN) 复杂度。 Knuth 等三位科学家发明了 KMP 算法，可以实现 O(M+N) 复杂度。

- wildCard

  带通配符的字符串模式。在 KMP 基础上增加了 通配符，? 表示任意单个字符，* 任意数量任意字符。用于文件查找，可以在 O(N) 或 O(M+N) 复杂度内处理掉。

- 正则

  字符串通用模式匹配

- 状态机

  通用的字符串分析。理论上与 正则 等价，但写起来比较复杂。

- LL LR

  字符串多层级结构分析。LR 是比 LL 跟强大的算法，但理论性比较强。stack 处理 HTML 语法分析就是 LR 的简化版。LR(1) 可以等于 LL(N)。
  



## 20201117 [字典树](./dict.html)
字典树：比较直观，按字符串的每个字符决定不同的树分支，叶子节点上的属性保存数量。
字典树用于统计一批字符串中各个字符串的出现频率。

### 写代码


## 20201122 [字典树](./dict_02.html)
代码参考 winter

得到字典树后，就可以逐个获得想要的出现次数最多、最少、或者其他的值。

对于统计数字出现次数的场景，可以通过对数字补位后处理成字符串，使用字典树来统计。


## 20201122 [KMP 算法](./kmp.html)
查找一个长字符串里是否包含另一个较短的字符串。

暴力算法：直接从长字符串每个字符开始匹配，是否包含短字符串，时间复杂度为 O(MN)。

KMP 算法：充分利用短字符串本身中包含的信息，如果有重复时，就可以节约计算量。

重点：获取到字符串的自重复信息，产生一个 **跳转表格**，通过此表格确定匹配失败时，往前跳转的长度。


## 20201122 [wildcard 算法](./wildcard.html)
加入了两种通配符 \* \?，匹配情况更复杂。

简化：
ab\*cd\*abc\*a\?d

问题：星号应该尽量匹配多还是匹配少？

最后一个星号应该尽量匹配多，前面的星号匹配尽量少。
开头的 ab 只匹配开始的字符，最后的 a?d 匹配最后的字符。
中间的一个星号加上一串字符，就是去字符串里寻找特定模式字符，类似 KMP。

如果有问号的话，需要写带问号的 KMP，比较复杂，为了简便使用正则来处理。如果把整个字符串都用正则来匹配，则会带来性能问题。

## 20201123 字符串匹配算法
1. BF 算法
  BF 是 Brute Force 的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。逻辑就是暴力循环主串（长度 n）和模式串（长度 m，n >= m），最差的时间复杂度为 O(n*m)。当主串为 “aaa...aaaa”（很多 a），模式串为 “aab”时，就会每次对比模式串的 m 个字符，共对比 n-m+1 次。然而，由于通常模式串不会对比 m 次，碰到不匹配就会停止，如果模式串的第一个字符和主串都不匹配，则只需要对比 n-m+1 次，复杂度为 O(n)。

1. RK 算法
  RK 算法（Rabin-Karp 算法）是借助哈希算法对 BF 算法进行改造，即对主串每个长度为 m 的子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。RK 算法的核心是对哈希算法的设计。RK 算法的时间复杂度为 O(n)，如果哈希算法设计得不好，最坏情况下会退化到 O(n*M)。

